/**
 * Build script to bundle CodeMirror highlighting for WebView
 * This creates a standalone bundle that can be injected into the WebView
 */

const fs = require('fs');
const path = require('path');

// For now, we'll create a placeholder that uses CodeMirror's highlighting structure
// In a production setup, you would use esbuild or webpack to bundle the actual CodeMirror packages

const outputPath = path.join(__dirname, '../components/editor/codemirror-highlight-bundle.js');

const bundleContent = '// CodeMirror Highlighting Bundle for WebView\n' +
// This bundle provides markdown syntax highlighting using CodeMirror's highlighting system
// Generated by build-codemirror-highlight.js

(function() {
  'use strict';
  
  // CodeMirror highlighting tags (from @lezer/highlight)
  // These match the tags used by CodeMirror's markdown language support
  const Tags = {
    heading: 1,
    strong: 2,
    emphasis: 3,
    link: 4,
    quote: 5,
    monospace: 6,
    strikethrough: 7,
    list: 8,
    codeBlock: 9,
    horizontalRule: 10,
    heading1: 11,
    heading2: 12,
    heading3: 13,
    heading4: 14,
    heading5: 15,
    heading6: 16,
  };
  
  /**
   * Highlights markdown using CodeMirror's highlighting structure
   * This implementation follows CodeMirror's markdown language specification
   */
  function highlightMarkdownWithCodeMirror(text, isDark, colors) {
    if (!text) return '';
    
    // This is a placeholder - in production, you would use the actual Lezer parser
    // For now, we'll use an improved version that follows CodeMirror's structure
    return highlightMarkdownImproved(text, isDark, colors);
  }
  
  /**
   * Improved markdown highlighter that follows CodeMirror's highlighting structure
   * Uses the same tags and structure as CodeMirror's markdown language support
   */
  function highlightMarkdownImproved(text, isDark, colors) {
    if (!text) return '';
    
    const foreground = colors?.foreground || (isDark ? '#fafafa' : '#0a0a0a');
    const primary = colors?.primary || '#3b82f6';
    const mutedForeground = colors?.mutedForeground || (isDark ? '#888' : '#666');
    const codeColor = isDark ? '#ff69b4' : '#d73a49';
    
    const lines = text.split('\\n');
    let html = '';
    let inCodeBlock = false;
    let codeBlockLang = '';
    let codeBlockStart = -1;
    
    for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
      const line = lines[lineIdx];
      let lineHtml = '';
      
      // Check for code block start/end (```) - CodeMirror tag: codeBlock
      const codeBlockMatch = line.match(/^(\\s*)(`{3})(\\w*)?/);
      if (codeBlockMatch) {
        if (inCodeBlock) {
          // End of code block
          inCodeBlock = false;
          codeBlockLang = '';
          lineHtml += '<span class="cm-codeBlock">' + escapeHtml(line) + '</span>';
        } else {
          // Start of code block
          inCodeBlock = true;
          codeBlockLang = codeBlockMatch[3] || '';
          codeBlockStart = lineIdx;
          lineHtml += '<span class="cm-codeBlock">' + escapeHtml(line) + '</span>';
        }
        html += lineHtml;
        if (lineIdx < lines.length - 1) html += '\\n';
        continue;
      }
      
      // If inside code block, treat entire line as code (CodeMirror tag: monospace)
      if (inCodeBlock) {
        lineHtml += '<span class="cm-monospace">' + escapeHtml(line) + '</span>';
        html += lineHtml;
        if (lineIdx < lines.length - 1) html += '\\n';
        continue;
      }
      
      // Headers (# ## ### #### ##### ######) - CodeMirror tags: heading, heading1-6
      const headerMatch = line.match(/^(#{1,6})\\s+(.+)$/);
      if (headerMatch) {
        const level = headerMatch[1].length;
        const headerText = headerMatch[2];
        const headingClass = 'cm-heading cm-heading' + level;
        lineHtml += '<span class="' + headingClass + '">' + escapeHtml(headerMatch[1] + ' ') + '</span>';
        lineHtml += highlightInlineMarkdownImproved(headerText, isDark, colors);
        html += lineHtml;
        if (lineIdx < lines.length - 1) html += '\\n';
        continue;
      }
      
      // Horizontal rules (--- or *** or ___) - CodeMirror tag: horizontalRule
      if (line.match(/^[-*_]{3,}\\s*$/)) {
        lineHtml += '<span class="cm-horizontalRule">' + escapeHtml(line) + '</span>';
        html += lineHtml;
        if (lineIdx < lines.length - 1) html += '\\n';
        continue;
      }
      
      // Blockquotes (>) - CodeMirror tag: quote
      if (line.match(/^>\\s/)) {
        lineHtml += '<span class="cm-quote">' + escapeHtml(line) + '</span>';
        html += lineHtml;
        if (lineIdx < lines.length - 1) html += '\\n';
        continue;
      }
      
      // List items (-, *, +, or numbered) - CodeMirror tag: list
      if (line.match(/^(\\s*)([-*+]|\\d+\\.)\\s/)) {
        const listMatch = line.match(/^(\\s*)([-*+]|\\d+\\.)\\s(.+)$/);
        if (listMatch) {
          lineHtml += '<span class="cm-list">' + escapeHtml(listMatch[1] + listMatch[2] + ' ') + '</span>';
          lineHtml += highlightInlineMarkdownImproved(listMatch[3], isDark, colors);
        } else {
          lineHtml += highlightInlineMarkdownImproved(line, isDark, colors);
        }
        html += lineHtml;
        if (lineIdx < lines.length - 1) html += '\\n';
        continue;
      }
      
      // Regular line - process inline markdown
      lineHtml += highlightInlineMarkdownImproved(line, isDark, colors);
      html += lineHtml;
      if (lineIdx < lines.length - 1) html += '\\n';
    }
    
    return html;
  }
  
  /**
   * Highlights inline markdown syntax using CodeMirror's tag structure
   * Tags: strong, emphasis, link, monospace, strikethrough
   */
  function highlightInlineMarkdownImproved(text, isDark, colors) {
    if (!text) return '';
    
    const foreground = colors?.foreground || (isDark ? '#fafafa' : '#0a0a0a');
    const primary = colors?.primary || '#3b82f6';
    const codeColor = isDark ? '#ff69b4' : '#d73a49';
    
    let result = '';
    let pos = 0;
    const len = text.length;
    
    while (pos < len) {
      let matched = false;
      
      // Inline code (`code`) - CodeMirror tag: monospace
      const codeMatch = text.substring(pos).match(/^`([^`]+)`/);
      if (codeMatch) {
        result += '<span class="cm-monospace">`' + escapeHtml(codeMatch[1]) + '`</span>';
        pos += codeMatch[0].length;
        matched = true;
        continue;
      }
      
      // Bold (**text** or __text__) - CodeMirror tag: strong
      const boldDoubleStar = text.substring(pos).match(/^\\*\\*([^*\\n]+?)\\*\\*/);
      const boldDoubleUnderscore = text.substring(pos).match(/^__([^_\\n]+?)__/);
      
      if (boldDoubleStar && boldDoubleStar[1].length > 0) {
        const beforeChar = pos > 0 ? text[pos - 1] : '';
        const afterPos = pos + boldDoubleStar[0].length;
        const afterChar = afterPos < len ? text[afterPos] : '';
        if (beforeChar !== '*' && afterChar !== '*') {
          result += '<span class="cm-strong">' + escapeHtml(boldDoubleStar[0]) + '</span>';
          pos += boldDoubleStar[0].length;
          matched = true;
          continue;
        }
      }
      
      if (!matched && boldDoubleUnderscore && boldDoubleUnderscore[1].length > 0) {
        const beforeChar = pos > 0 ? text[pos - 1] : '';
        const afterPos = pos + boldDoubleUnderscore[0].length;
        const afterChar = afterPos < len ? text[afterPos] : '';
        if (beforeChar !== '_' && afterChar !== '_') {
          result += '<span class="cm-strong">' + escapeHtml(boldDoubleUnderscore[0]) + '</span>';
          pos += boldDoubleUnderscore[0].length;
          matched = true;
          continue;
        }
      }
      
      // Strikethrough (~~text~~) - CodeMirror tag: strikethrough
      const strikeMatch = text.substring(pos).match(/^~~([^~\\n]+?)~~/);
      if (strikeMatch && strikeMatch[1].length > 0) {
        result += '<span class="cm-strikethrough">' + escapeHtml(strikeMatch[0]) + '</span>';
        pos += strikeMatch[0].length;
        matched = true;
        continue;
      }
      
      // Links [text](url) or [text](url "title") - CodeMirror tag: link
      const linkMatch = text.substring(pos).match(/^\\[([^\\]]+)\\]\\(([^\\)]+)(?:\\s+"([^"]+)")?\\)/);
      if (linkMatch) {
        result += '<span class="cm-link">' + escapeHtml(linkMatch[0]) + '</span>';
        pos += linkMatch[0].length;
        matched = true;
        continue;
      }
      
      // Images ![alt](url) - CodeMirror tag: link
      const imageMatch = text.substring(pos).match(/^!\\[([^\\]]*)\\]\\(([^\\)]+)\\)/);
      if (imageMatch) {
        result += '<span class="cm-link">' + escapeHtml(imageMatch[0]) + '</span>';
        pos += imageMatch[0].length;
        matched = true;
        continue;
      }
      
      // Italic (*text* or _text_) - CodeMirror tag: emphasis
      if (!matched) {
        if (text[pos] === '*' && pos + 1 < len) {
          const beforeChar = pos > 0 ? text[pos - 1] : '';
          if (beforeChar !== '*') {
            const nextStar = text.indexOf('*', pos + 1);
            if (nextStar > pos + 1) {
              const afterChar = nextStar + 1 < len ? text[nextStar + 1] : '';
              if (afterChar !== '*') {
                const italicText = text.substring(pos, nextStar + 1);
                if (italicText.length > 2) {
                  result += '<span class="cm-emphasis">' + escapeHtml(italicText) + '</span>';
                  pos = nextStar + 1;
                  matched = true;
                  continue;
                }
              }
            }
          }
        }
        
        if (!matched && text[pos] === '_' && pos + 1 < len) {
          const beforeChar = pos > 0 ? text[pos - 1] : '';
          if (beforeChar !== '_') {
            const nextUnderscore = text.indexOf('_', pos + 1);
            if (nextUnderscore > pos + 1) {
              const afterChar = nextUnderscore + 1 < len ? text[nextUnderscore + 1] : '';
              if (afterChar !== '_') {
                const italicText = text.substring(pos, nextUnderscore + 1);
                if (italicText.length > 2) {
                  result += '<span class="cm-emphasis">' + escapeHtml(italicText) + '</span>';
                  pos = nextUnderscore + 1;
                  matched = true;
                  continue;
                }
              }
            }
          }
        }
      }
      
      // If no match, add the character
      if (!matched) {
        result += escapeHtml(text[pos]);
        pos++;
      }
    }
    
    return result;
  }
  
  /**
   * Escapes HTML special characters to prevent XSS attacks
   */
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // Export the highlighting function
  window.CodeMirrorHighlight = {
    highlightMarkdown: highlightMarkdownWithCodeMirror,
    Tags: Tags
  };
})();
`;

// Write the bundle file
fs.writeFileSync(outputPath, bundleContent, 'utf8');
console.log('CodeMirror highlighting bundle created at:', outputPath);
